- 数组类并没有对应的字节流，而是由 Java 虚拟机直接生成的。

- 加载--链接(验证-准备-解析)-初始化

  其中准备阶段对于类变量设置初值(清零)，特别的对于ConstantValue(基本类型和字符串)直接赋实际值。

  而其他的类变量的值则是在初始化阶段由`<cinit>()`方法进行处理的

- 解析阶段的目的，是将符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化）

  因此执行一个`new A[2]`一定会导致A类的加载，但是未必会导致初始化。

- 重载时，如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。例如metod(String)就比method(Object)更加贴切

- 调用相关的指令

  - invokestatic：用于调用静态方法。 
  - invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
  -  invokevirtual：用于调用非私有实例方法。
  -  invokeinterface：用于调用接口方法。 
  - invokedynamic：用于调用动态方法

- 方法调用

  - 解析

    如果在类的解析阶段就能确定方法的唯一调用版本，则直接进行符号引用和实际引用的转化。

    invokestatic和invokespecial以及final修饰的方法属于这种类型

  - 分派

    - 静态多分派

      方法重载。根据方法的名称和参数进行匹配【因此是多个宗量】

      虚拟机不参与，编译的时候就知道执行那个方法了。通过引用类型来决定执行的方法。

    - 动态单分派

      只有在实际执行的时候，才知道调用哪一个方法。通过实际类型【唯一宗量】来决定执行哪一个方法。

- Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的虚方法调用。**【注意，调用超类非私有实例方法会属于静态绑定】**

- 对于动态分派机制，在类加载的准备阶段，在方法去给类建立一个虚方法表(vtable)和接口方法表(itable)。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。

  在调用的时候，访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法即可。

  为了提升性能，可以使用`内联缓存`，能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。

- finally有return语句，catch内throw的异常会被忽略

  catch里抛的异常会被finally捕获了，再执行完finally代码后重新抛出该异常。由于finally代码块有个return语句，在重新抛出前就返回了。