1. 客户端将消息发送给primary节点
2.1 primary对消息进行编号，然后将[pre-prepare]消息发送给各个节点
2.2 每一个节点校验收到的消息，如果认同这个消息就将[prepare]消息发送给其他所有的节点
2.3 每一个节点接收到其他点的prepare消息，如果收到了2f+1(包括自己)个点的prepare消息，就将[commit]消息发送给其他的节点
2.4 每一个节点接收到其他点的commit消息,果收到了2f+1(包括自己)个点的commit消息,就进入local-commit状态，将请求响应到客户端

pre-prepare和prepare 是确保节点编号的统一，达成在同一个view下的节点共识。
prepare和commit，是确保在view的切换的时候，不会出现消息丢失/重复的问题，确保view之间也能够达成节点共识

在view切换的时候，只要有f+1个节点发起view的切换就可以了[如果是恶意切换节点的话，最多只能有f个节点支持]。
那么就可以知：

1. f+1个节点发起view切换，将他们当前的状态发布出来[包括当前处理的消息的编号]
2. 前面提到的commit，只有2f+1个点同意才能commit。
这样就却保了1.2中的点必定有一个是重叠的，因此系统中的数据不会丢失。至少有一个点在view-change的时候拥有全部的数据。

这样view-chang之后，新的primary收集所有参与view-change投票的节点的信息，然后从当前的checkpoint开始。
重新发起三段共识算法。由此完成了节点的切换，此时所有请求也都没有丢失。已经写入到区块链中的数据(checkpoint之前)也不会丢失。

- client和primary合二为一。意思是说每一个节点本身可以发起写区块的请求，首先发给primary，当失败的时候，就广播给每一个区块，去找寻正确的primary。

